'use strict'
/*

Задача № 1. Палитра для сайта

Мы хотим для каждого пользователя выдавать наш сайт в уникальных цветах. И первое, что для этого нужно сделать — это реализовать генератор цветовой палитры с аналогичными цветами.

Для этого вам потребуется реализовать генератор palette, который принимает количество цветов и создает итератор цветов.
Описание генератора

Создает итератор сгенерированных цветов. Принимает один аргумент:

    amount — количество цветов, которое нужно сгенерировать, число.

Описание итератора

Количество итераций равно числу, которое передано в генератор palette. В каждой итерации должен вернуть цвет в шестнадцатеричном представлении формата RGB, например #f8dff2, который обычно применяется в CSS.

Для генерации аналогичных цветов удобнее всего использовать формат HSL. Потому что в нём цвет состоит из тона (hue), насыщенности (saturation) и светлоты (lightness). У аналогичных цветов насыщенность и светлота будут одинаковыми, а тон будет отличаться на равные значения. Тон обычно представляют в виде цветового круга. Тон, равный 0 (0˚), и тон, равный 1 (360˚), совпадают.

И, если нам нужно получить 3 цвета, мы можем взять на круге 3 точки через каждые 120˚ (360 / 3): например, 33˚, 153˚ и 273˚, что соответствует тонам 33/360, 153/360 и 273/360. Сгенерировав случайный тон, насыщенность и светлоту и получив нужное количество тонов, останется только перевести полученный цвет в RGB-формат. Для этого воспользуйтесь функцией hslToRgb
Описание функции hslToRgb

Функция принимает три числа, соответствующие трем компонентам HSL представления цвета: тону, насыщенности и светлоте:

    hue — тон, число от 0 до 1;
    saturation — насыщенность, число от 0 до 1;
    lightness — светлота, число от 0 до 1.

Функция возвращает строку в формате RGB.
Пример использования


for (const color of palette(3)) {
  console.log(color);
}

Если все реализовано верно, вы получите три случайных аналогичных цвета:


#817a8d
#8d817a
#7a8d81

Процесс реализации

    Создайте генератор palette.
    Сгенерируйте случайный тон, насыщенность и светлоту.
    Определите шаг изменения тона, исходя из количества, которое нужно сгенерировать.
    Меняйте тон в цикле на полученный шаг.
    Если значение тона превысило 1, просто уменьшите его на 1.
    В каждой итерации возвращайте в итератор RGB-цвет для полученных насыщенности, светлоты и текущего тона.
    Количество итераций должно быть равно количеству цветов.


*/

function hslToRgb(h, s, l) {
  let r, g, b;

  if(s == 0) {
    r = g = b = l; // achromatic
  } else {
    const hue2rgb = function (p, q, t) {
      if(t < 0) t += 1;
      if(t > 1) t -= 1;
      if(t < 1/6) return p + (q - p) * 6 * t;
      if(t < 1/2) return q;
      if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
      return p;
    };

    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }

  function colorToHex(color) {
    let hex = Math.round(color * 255).toString(16);
    return hex.length < 2 ? `0${hex}` : hex;
  }

  const color = [r, g, b].map(colorToHex).join('');
  return `#${color}`;
}

function* pallete(amount){

  let range = parseInt(360 / amount);
  let hue = 0;
  let saturation = 0;
  let lightness = 0;
  let from = 0;
  let to = range -1;

  function random(min, max){
    return Math.random() * (max - min) + min;
  }
  
  for(let i = 0; i < amount; i++){

    hue = random(from, to) / 360;
    saturation = random(from, to) / 360;
    lightness = random(from, to) / 360;

    from += range;
    to += range;

    yield hslToRgb(hue, saturation, lightness);
  }
  return;
}

for(let color of pallete(5)){
  console.log(color);
}